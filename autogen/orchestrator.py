import asyncio
from autogen import AssistantAgent, UserProxyAgent, GroupChat, GroupChatManager
from coding_agent import CodingAgent
from test_suite_agent import TestSuiteagent
from reviewer_agent import ReviewerAgent
import os
import shutil
from dotenv import load_dotenv
import re

load_dotenv(override=True)
deepseek_api_key = os.getenv('DEEPSEEK_API_KEY')

llm_config = {
    "model": "deepseek-chat",          # model name
    "api_key": deepseek_api_key,       # set via env var for security
    "base_url": "https://api.deepseek.com/v1"
}

def setup_project(project_name="AutoGenerated", test_project_name="AutoGeneratedTests", output_dir="generated"):
    project_root = os.path.join(r"C:\Users\p_vis\source\repos", output_dir)
    cs_proj_dir = os.path.join(project_root, project_name)
    test_proj_dir = os.path.join(project_root, test_project_name)
    sln_file = os.path.join(project_root, f"{project_name}Solution.sln")

    if os.path.exists(project_root):
        shutil.rmtree(project_root)
    os.makedirs(project_root)

    print(f"Creating C# console project in {cs_proj_dir}...")
    os.system(f"dotnet new console -n {project_name} -o {cs_proj_dir}")

    print(f"Creating NUnit test project in {test_proj_dir}...")
    os.system(f"dotnet new nunit -n {test_project_name} -o {test_proj_dir}")

    print(f"Creating solution file {sln_file}...")
    os.system(f"dotnet new sln -n {project_name}Solution -o {project_root}")

    print(f"Adding projects to solution...")
    os.system(f"dotnet sln {sln_file} add {cs_proj_dir}/{project_name}.csproj")
    os.system(f"dotnet sln {sln_file} add {test_proj_dir}/{test_project_name}.csproj")

    print(f"Adding project reference from {test_project_name} to {project_name}...")
    os.system(f"dotnet add {test_proj_dir}/{test_project_name}.csproj reference {cs_proj_dir}/{project_name}.csproj")

    print("C# project setup complete.")
    return cs_proj_dir, test_proj_dir, project_root

def save_code_to_file(directory, filename, code):
    """Saves generated code to a specified file."""
    filepath = os.path.join(directory, filename)
    with open(filepath, "w") as f:
        f.write(code)
    print(f"Saved code to {filepath}")

async def run_code_generation_workflow(problem_statement):
  
    print(f"\n--- Starting workflow for: {problem_statement} ---")

    # 1. Setup C# Project Structure
    cs_proj_dir, test_proj_dir, project_root = setup_project()

    user_proxy = UserProxyAgent(
        name="user",
        human_input_mode="NEVER", # Set to "ALWAYS" or "TERMINATE" for manual intervention
        max_consecutive_auto_reply=10,
        is_termination_msg=lambda x: x.get("content", "").rstrip().endswith("TERMINATE"),
        code_execution_config={"work_dir": project_root, "use_docker": False} # Set use_docker to True for sandboxed execution
    )

    coding_agent = CodingAgent.create_agent(llm_config)
    test_agent = TestSuiteagent.create_agent(llm_config)
    reviewer_agent = ReviewerAgent.create_agent(llm_config)

    groupchat = GroupChat(
        #agents=[user_proxy, coding_agent, reviewer_agent, test_agent],
        agents=[user_proxy, coding_agent, test_agent],
        messages=[],
        max_round=10,
        speaker_selection_method="round_robin"
    )

    manager = GroupChatManager(groupchat=groupchat, llm_config=llm_config)

    print("\n--- Initiating chat with agents ---")

    chat_result = user_proxy.initiate_chat(
        manager,
        message=f"Create a C# class solution for the following problem: {problem_statement}. "
                "The CodingAgent should provide the initial C# class/method."
                "The TestAgent should then write NUnit unit tests for the C# code."
                "Once the code and tests are finalized, please output them in separate blocks."
                "End the conversation with 'TERMINATE'."
    )

    final_code = None
    final_tests = None
    code_pattern = re.compile(r"```(csharp|c#)(.*?)```", re.DOTALL | re.IGNORECASE)

    for msg in chat_result.chat_history:
        content = msg.get("content", "")
        agent_name = msg.get("name", "")

        if "AutoGenCodingAssistant" in agent_name:
            for match in code_pattern.finditer(content):
            # This will capture the last C# code block from the coding agent
            # or any agent that outputs csharp code as a final result.
                extracted_block = match.group(2).strip()
                if "class" in extracted_block and "[Test]" not in extracted_block:
                    final_code = extracted_block
        elif "TestSuiteAssistant" in agent_name:
            # This will capture the last C# test code block
            for match in code_pattern.finditer(content):
                extracted_block = match.group(2).strip()
                if "[Test]" in extracted_block or "NUnit" in extracted_block:
                    final_tests = extracted_block

    if final_code:
        save_code_to_file(cs_proj_dir, "Program.cs", final_code)
    else:
        print("Could not extract final C# code.")

    if final_tests:
        save_code_to_file(test_proj_dir, "Tests.cs", final_tests)
    else:
        print("Could not extract final C# tests.")

    print("\n--- Workflow finished ---")
    print("Check the 'generated' directory for your C# project and files.")

if __name__ == "__main__":
    # define the task
    input_problem = "Write a function to compute factorial using recursion."
    #"Create a BankAccount class with Deposit, Withdraw, and Balance properties. Prevent overdrafts."
    asyncio.run(run_code_generation_workflow(input_problem))
